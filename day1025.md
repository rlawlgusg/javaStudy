# 예외처리
예외 : 프로그램 실행중에 예기치 않는 상황이 발생하는 것

예외처리 : "예외"를 처리하는 것

예시 

1) `int a = 4/0;`

자바가 자동으로 new ArithmeticException()을 생성

2) 배열의 인덱스 범위를 넘음
```
int []a = {1,2,3};
int n = a[3];
``` 
`new ArrayIndexOutOfBoundsException()` 객체를 자바가 자동으로 생성  

일반적으로 발생할 수 있는 예외에 대해서는 자바가 이미 클래스를 만들어 놓았고 자동으로 "예외객체"가 생성됌

예외처리를 하기위한 기본 방식 :  

예외가 발생이 될만한 문장들을 try{    } 안에 쓰고 

예외가 발생되었을 때 처리할 문장을 catch(예외클래스명 변수명){   } 에다가 씀

1. 하나의 try안에 여러개의 catch절이 올 수 있음
2. catch절의 순서는 범위가 작은 예외클래스 순서대로 와야함!!!
3. 예외가 발생하거나 정상적으로 동작하거나 반드시 처리해야할 명령이 있다면 finally를 사용

```
try{ 
   예외가 발생이 될만한 문장(들)
}catch(예외클래스명1 변수명){
   예외가 발생되었을 때 처리할 문장(들)
}catch(예외클래스명2 변수명){
   예외가 발생되었을 때 처리할 문장(들)
}catch(예외클래스명3 변수명){
   예외가 발생되었을 때 처리할 문장(들)
}finally{
   정상적으로 동작하거나 에외가 발생거나 반드시 처리해야할 명령어(들)
}
```
# throws 

어떤 메소드안에서 예외가 발생할 만한 명령어 들이 있다고 가정할때 메소드 내용과 예외처리까지 쓰다보면 메소드가 길어짐

길어짐 방지를 위해 메소드 안에서는 메소드처리를 위한 핵심내용만 쓰고 예외처리는 메소드를 호출하는 쪽에다가 맡김 

이말은 예외를 메소드를 호출하는 쪽으로 "던진다"

키워드는 메소드 이름 뒤에 써줌 
```
public void 메소드이름() throws 예외클래스이름{
}
```

위의 메소드를 사용하려면 메소드를 **호출하는 쪽**에서 try-catch로 예외 처리를 해야함

# RuntimeException 

예외와 관련하여 제일 조상 클래스는 Exception클래스

Exception 클래스의 후손클래스들 중에서

RuntimeException의 후손클래스들은 사용자가 특별히 예외처리를 하지 않아도 자바가 예외처리를 해줌!

그러나 **RuntimeException의 후손이 아닌 예외들은 반드시 사용자가 예외처리를 해 주어야 함**
```
입출력과 관련한 클래스들을 모아 놓은 java.io 패키지
네트워크 통신과 관련한 클래스들을 모아놓은 java.net 패키지
데이터베이스 연결과 관련한 클래스들을 모아 놓은 java.sql 패키지의 
대부분의 생성자 및 메소드들은 예외를 포함하고 있으며 그것은 모두 RUNTIMEEXCEPTION의 후손이 아님 
따라서 이것들을 사용하려면 사용자가 반드시 예외처리를 해야함
```

자바의 예외들 중에 RuntimeException의 하위 예외들을 사용자가 특별히 예외처리를 하지 않아도 컴파일이 됌

즉, 자바가 예외처리를 해 줌

그러나 RuntimeException의 하위 예외가 아닌 예외들은 사용자가 반드시 예외처리를 해야 컴파일이 됌 
```
java.io
java.net
java.sql
```
의 대부분의 생성자와 메소드들은 RuntimeException 하위 예외가 아닌 예외들을 포함하고 있음

# throw

자바는 대부분의 일반적인 예외상황에 대해서는 이미 클래스가 만들어져 있고 그 상황이 되면 자동으로 예외 객체가 생성됌

사용자가 강제로 예외를 발생시켜야 하는 상황이라면 throw를 사용

사용하는 방법 `throw new 예외클래스이름();`

# 사용자정의 예외

내가 만들고 있는 프로젝트에서만 처리되는 특수한 경우의 문제의 상황을 예외로 만들고자 한다면

즉, 자바는 모르고 있는 어떠한 상황이 있다면 사용자가 직접 예외를 만들 수 있음

사용자 정의 예외클래스를 만드는 방법은 예외클래스들의 제일 조상인 Exception을 상속받아 클래스를 만듬

특별히 해 줄 것은 없고 생성시에 예외메세지를 전달받아 부모생성자에게 전달만 해주면 됌 
```
class 사용자정의예외클래스이름 extends Exception{
   public 사용자정의예외클래스이름(String msg){
    		super(msg);
   }
}

if( 문제의 상황인지 조건식 ){
	throw new 사용자정의예외클래스이름("메세지");
}
```
여태까지 문제의 상황을 if 조건식에 물어보고 적절한 메세지를 출력하여 처리했지만 

프로젝트에서는 미리 이러한 상황은 "문제로 인식하자" 라는데에 의미가 있음 
