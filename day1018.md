# 접근명시자의 종류
1.private : 자기자신 이외의 모든 클래스로부터 보호

2.public : 외부의 모든 클래스에게 접근 허용

3.protected : 외부의 다른 클래스로부터는 보호하되 상속받은 자식클래스들에게는 접근 허용

4.default : 접근명시자를 아무것도 안 적는것을 말함, 이것은 외부의 다른 클래스들에게는 접근을 허용하지 않고 이 클래스와 같은 패키지내의 클래스들에게는 접근을 허용함 

# 추상메소드와 추상클래스

일반화 : 클래스를 만들때 미래에 만들어지는 자식클래스들이 가져야 할 공통적인 속성과 동작들을 모아서 부모클래스를 만듬 이 메소드는 body를 구체화 할 수 없음 

추상메소드 : 

반드시 후손클래스들이 가져야 하고 오버라이딩 해야할 메소드가 있을때 메소드의 body를 구체화 하지 않고 메소드 선언부만 적음 
            
추상메소드임을 나타내기 위하여 메소드이름 왼쪽에 abstract키워드를 붙여야함 

클래스가 추상메소드를 하나라도 갖고 있으면 그 클래스 자신이 추상클래스가 되어야 하며 클래스이름 왼쪽에 abstract키워드를 붙여야함

어떤 클래스가 추상클래스로 부터 상속받았다면 그 추상클래스내의 **모든 추상메소드를 오버라이딩** 해야함

지키지 않으면 오류가 발생함! 

추상클래스라고 하는 것은 body가 구체화되지 않는 메소드를 포함하고 있기 때문에 추상클래스의 객체는 생성할 수 없음!

추상메소드들을 오버라이딩 한 상속받은 자식 클래스는 클래스의 객체를 생성할 수 있음  

*instanceof 연산자 : 어떤 객체가 특정 클래스의 자료형인지 판별하기 위한 연산자* 

## 이클립스에서 클래스이름을 변경하고자 할때 ##
1.package Explorer에서 바꾸고자 하는 클래스명을 선택 
2.마우스 오른쪽 단추 눌러 Refacter >Rename을 선택 후 이름을 변경함! 

파일명도 바뀌고 클래스명도 바뀌고 이 클래스를 사용하던 모든 소스코드도 한번에 변경됨 

**추상클래스에 대하여 설명하시오**

body가 구체화 되지 않는 추상메소드를 포함하고 있는 클래스를 말하며 일반 속성과 메소드를 포함할 수 있음

추상클래스의 객체는 생성 불가

**추상메소드에 대하여 설명하시오**

미래에 자식클래스들이 가져야할 속성과 동작을 일반화 함에 있어 어떠한 메소드를 부모클래스를 만드는 시점에서 구체화 할 수 없으나 

반드시 자식클래스들은 그 메소드를 가져야 하고 자식클래스들이 반드시 오버라이딩 해야 할 때 이러한 메소드는 메소드를 구체화 하지 않고 메소드 선언부만 적어 추상메소드로 만듬

추상메소드임을 나타내기 위하여 abstract 키워드를 붙여야 함 

일반적으로 어떤 클래스의 멤버변수는 필요에 따라 값이 변경될 수 있음!

일반적으로 어떤 클래스를 확장하여 새로운 클래스를 만들 수 있음!

일반적으로 상속관계에 있을 때 부모의 메소드가 자식클래스에게 알맞지 않으면 오버라이딩할 수 있음!

# final

**클래스의 멤버변수이름 앞에 final**

변수이기는 하지만 정해진 값 이외의 다른 값으로 못바꾸도록 함!! = 상수로 만든다

"상수" (숫자만 상수가 아니라 문자열 데이터도 상수라고 함...) 

ex "hello" 문자열 데이터도 상수임 

**다른값으로 바꿀 수 없기때문에 객체마다 따로 메모리 확보하지 않고 하나를 만들어서 같이 사용하도록 함!! static으로 만듬!**

**클래스의 멤버메소드 이름 앞에 final**

상속관계에 있는 자식클래스들에게 오버라이딩 금지

클래스의 클래스이름 앞에 final, 클래스의 상속금지 

**final키워드에 대하여 설명하시오**

final키워드는 클래스의 멤버변수명 앞에, 메소드명 앞에, 클래스명 앞에 올 수 있음

변수명 앞에 final은 변하지 않는 상수를 만들기 위함이며 보통 static변수로 만들어 사용

메소드명 앞에 final은 상속관계에 있을 때 오버라이딩 금지를 위하여 사용

클래스명 앞에 final은 그 클래스의 상속을 금지하기 위하여 사용

**final변수는 다른 일반 속성과 구별하기 위한 용도로 보통 모두 대문자로 만듬!
```
Math.PI
Integer.MAX_VALUE
Integer.MIN_VALUE
```
```
Class A{
}

Class B{
}
Class C extends A,B{
} //이건 불가능!
```
자바에서는 클래스의 다중상속이 금지되어있기 때문에 자바에서는 다중상속의 효과를 기대할 목적으로 인터페이스를 사용함

인터페이스는 클래스 만드는 것 처럼 만듬 즉, 인터페이스는 새로운 자료형의 개념
```
class 클래스이름{
}
```
처럼 클래스를 만들듯이 
```
interface 인터페이스이름{
}
```
으로 인터페이스를 만듬

인터페이스는 "완전추상"의 개념이며 구성요소로 올 수 있는 것은 상수와 추상메소드만으로 구성되어야 함!

완전추상이기때문에 인터페이스안에서 변수명앞에 따로 final을 붙이지 않아도 자동 final

메소드이름 앞에 final을 붙이지 않아도 자동 abstract임 

인터페이스의 자식클래스를 인터페이스를 구현한다고 하며 다음과 같이 사용

클래스를 상속할 때에는 
```
class 자식클래스이름 extends 부모클래스이름{
}
```
과 같이 표현하며 인터페이스를 구현하는 클래스는
```
class 자식클래스이름 implements 부모인터페이스이름{
}
```
과 같이 표현함 
```
class A{
}
interface B{
}
```
위와 같이 A클래스가 있고 인터페이스 B가 있다고 할때 A클래스를 상속받고 B인터페이스를 구현하는 클래스는 다음과 같이 표현할 수 있음
```
class C extends A implement B{
}
```
이때 C는 B인터페이스 안에 있는 모든 메소드를 오버라이딩해야하는 책임이 있음
```
class A{
}
interface B{
}
interface k{
}
class c extends A implements B,k{
}
```
클래스의 상속은 하나밖에 되지 않지만 인터페이스의 구현은 얼마든지 가능

C는 B,K인터페이스의 모든 메소드들을 오버라이딩 해야함 
