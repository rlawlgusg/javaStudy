# 배열
자료형이 같은 기억장소가 많이 필요할 때 

일일이 변수이름을 정해주지 않고 대표하는 이름과 자료형과 크기를 정해 주어 한꺼번에 많은 변수를 확보가능! 

반복문을 사용하여 일괄처리 도 가능!
 
`int a[];` 

이때 a는 배열의 이름 []기호는 배열임을 표시

`a = new int[5];` a가 int형 5개 만큼 메모리를 확보하라는 의미

위의 두 문장을 한줄로 표현할 수도 있음!

`int a[] = new int[5]`

또 배열이라는 기호 []를 배열이름 앞에 쓸 수도, 뒤에 쓸 수도 있음

`int []a = new int[5]`

또 배열의 요소가 처음부터 정해진 경우라면 배열을 선언함과 동시에 초기화 가능

`int []a = {10,20,30,40,50};`

위와같이 배열을 선언함과 동시에 초기화 하게 되면 자동으로 **배열의 길이는 초기화 한 데이터의 수 만큼 정해짐**

배열은 자동으로 초기값을 가짐.. 

자료형에 따라 boolean은 false , String은 null, 정수는 0, 실수는 0.0으로 초기화 됌

`int a;`라고 해놓고 초기화 하지 않은 상태로 a변수를 사용할 수 는 없음

다음과 같이 출력하면 에러가 발생

`System.out.println(a);`

그러나 배열의 경우는

`int []b = new b[5];` 라고 하면 5개의 기억장소 모두 0으로 초기화 됌

따라서 다음과 같이 출력문을 사용가능

`System.out.println(b[0]);` 0이 출력됌

그러나 배열을 선언하기만 하고 배열의 메모리 확보를 하기전에는 사용불가

`int []k;` 라고만 하면 아직 배열이 확보되기 전이기 때문에 사용불가

`k[0] = 5;` 라고 사용하면 오류 발생

위에서 k를 정수형의 배열로 쓰겠습니다 라고한것이지 크기가 정해지지 않았기 때문에 사용할 수 없음 

## 다차원 배열
### 일차원 배열
`int []a = new int[5]` 와 같은 경우를 일차원 배열이라함!

### 이차원 배열
만약에 5개짜리 정수형 변수가 3묶음 필요하다면 다음과 같이 표현가능

`int[][]a = new int[3][5]` 3묶음짜리가 5개 필요하다!

위의 경우를 2차원 배열이라고하며 2차원 배열이상을 다차원 배열이라고 함!

5칸짜리 정수형 변수가 3줄 있다  즉, 정수형 변수가 15개 만들어짐 
보통 행, 열로 이야기함  3행 5열의 이차원 배열 이라고 함 

위의 이차원 배열을 일괄처리 하려면 **중첩 반복문**을 이용해야함
**행을 위한 반복문 안에서 열을 위한 반복문이 돌아야함**

### 삼차원 배열

만약에 5칸짜리 정수형 변수가 3묶음 있고 그런것이 2장 필요하다면 다음과 같이 표현가능

`int [][][]a = new int[2][3][5];` 위의 경우를 삼차원 배열 이라함 2면,3행,5열으로 생각

이것을 일괄처리 하기 위해서는 **세개의 중첩 반복문**을 이용해야 함

일반적으로 특별한 경우가 아니면 삼차원 배열 이상은 잘 사용하지 않음

#### 배열의 단점
**자료형이 같아야 한다**

`int []a = new int[5]`  라고 해두면 int밖에 담을 수 없고 5개밖에 담을 수 없음

사용자가 어떤 자료형을 담을지 또 몇개를 담을지 *예측하기 어려운 경우에는 배열을 사용하기 불편함* 
이러한 배열의 단점을 보완하기 위하여 자바는 향상된 배열인 "컬렉션 프레임워크"를 제공함

따라서 기본 자료형의 배열보다는 컬렉션 프레임워크를 사용하는 것이 더 일반적임
크기가 고정되어 있다

**자바의 이차원 배열에서는 각 행마다 열의 크기가 다를 수 있음**

`int [][]a = {{1,2},{3,4,5,6},{7,8,9}};` 그러면 이거 일괄처리 어떻게 하나요?
```
for(int i=0 ; i<3 ; i++){
  for(int j=0;j<a[i].length ; j++){
  }
}
```
그래서 자바에서는 각 행마다 열의 크기가 다를 수 있으므로 배열의 길이를 위한 속성을 사용함 
```
2차원 배열명인 a.length는 3입니다
첫번째 요소인 a[0].length는 2입니다
두번째 요소인 a[1].length는 4입니다
세번째 요소인 a[2].length는 3입니다
```
#### 기본자료형 변수와 참조자료형 변수
기본자료형 변수는 변수 자신이 값을 가지지만 참조자료형 변수는 변수 자신이 값을 갖고 있는 것이 아니라 값이 있는 메모리를 참조함

`int a = 10;` 위의 문장에서 a는 기본자료형 변수이며 변수 자신이 10이라는 값을 갖고 있음 

그러나 다음의 배열에서는 `int []b = {10,20,30,40,50}`

배열이름 b는 변수 자신이 값을 갖고 있는 것이 아니라 **값이 있는 메모리를 참조함**

이러한 배열을 **참조자료형** 이라고 함!

### 메소드
어떠한 문제해결을 위한(기능을 위한) 서로 관련있는 명령어들의 집합

매번 똑같은 명령어들을 일일이 쓰지 않고 메소드를 호출하여 사용할 수 있음 

메소드가 수행하는 일에 알맞도록 이름을 정해주고 소괄호를 반드시 열고 닫고 해야함

또, 메소드를 소괄호 안에는 그 메소드 실행에 필요한 값을 전달받을 수도 있음

메소드의 역할에 따라 값을 전달받지 않을 수도 있고 한개 전달 받을 수도 있고 때에 따라 여러개 전달 받을 수 있음

실제로 메소드가 해야하는 명령어들은 중괄호{} 속에다가 써줌
```
메소드이름([자료형 변수명1, 변수명2, ....] ){
	메소드가 해야할 명령어(들)
}
```
메소드를 만들어 놓고 필요할 때에 메소드 이름을 써주면 메소드의 중괄호{} 안의 명령어들이 차례로 동작하고 동작이 끝나면 메소드를 호출한 쪽으로 되돌아감 

때로는 메소드 {}중간에서 다 끝나기도 전에 어떠한 상황에 따라 중간에 나머지 명령어들을 마저 동작하지 않고 되돌아 가게 할 수도 있음

그때 되돌아 가게 하기 위한 명령어는 **return**임!!

메소드{}의 맨끝에는 return이라는 말을 쓰지 않아도 생략이 된것임...

메소드를 만들때 **메소드 이름 왼쪽에 메소드의 자료형을 써** 주어야 함 

메소드의 자료형이란 메소드는 호출문에 의해서 동작하고 메소드의 내용이 다 끝나면 메소드를 호출한 쪽으로 되돌아감 

이때 되돌아 갈때에 메소드 안에서 처리된 어떠한 결과값을 갖고 되돌아 갈 수도 있고 아무값도 갖지 않고 빈손으로 되돌아갈 수 도 있음 

만약 **되돌아 갈때에 아무값도 갖지 않고 가는 경우를 "리턴값이 없다!"** 라고 하고 어떠한 처리된 결과 값을 갖고 가는 경우라면 "리턴값이 있다"라고 함....

만약 리턴값이 있는 경우라면 메소드 이름 왼쪽에 리턴값의 자료형을 써줌 
     **리턴값이 없는 경우 void**라고 써줌
```
void 메소드이름( ){
	return;
}
```
의 경우 리턴값이 없으므로 메소드이름 왼쪽에 void라고 써야함

메소드의 이름이 다음과 같다면
```
int 메소드이름( ){
 int sum = 0;
 어쩌구저쩌구
 return sum;
}
```
위의 경우는 리턴값이 있으므로 메소드이름 왼쪽에 리턴값의 자료형인 int를 써주어야함

메소드를 만들기 위해서는 그 메소드를 사용하는 클래스 안에서 메소드를 만들 수도 있고 별도의 메소드를 포함하는 클래스를 만들어 사용할 수도 있음!

우리가 어떠한 클래스안에 메소드를 만들어 놓고 그 메소드를 사용하려면 
Scanner의 next메소드를 사용하거나 Random의 next를 사용하거나 Date의 getYear을 사용할 때 처럼

**반드시 객체를 생성해 놓고 그 객체를 통해서 메소드를 사용할 수 있음**

그런데 만약 System.out.println()처럼 객체 없이도 사용하게 하려면 

**메소드이름 왼쪽에 static을 붙이면 객체를 생성하지 않고 클래스이름.메소드이름()으로 바로 사용할 수도 있음**

만약 구구단을 출력할 일이 많다면 다음과 같이 몇단을 출력할 것인지 변수로 전달받아 해당하는 구구단을 출력하는 메소드를 만들 수 있음

MyUtil이라는 클래스를 만들고 그 클래스 안에 dan을 매개변수로 전달받아 구구단을 출력하는 gugudan 메소드를 만들어봄

```
class MyUtil{
	void gugudan(int dan){ //gugudan이 메소드 이름 (int dan)메소드 실행에 필요한 값을 전달받는 변수 = 매개변수
		System.out.printf("***%d단\n***",dan);
		for(int i=1;i<=9;i++){
			System.out.printf("%d*%d=%d\n",dan,i,dan*i);
		}
	} //메소드 바디 , return생략, return값이 없다! = void , 실제로 메소드가 해야할 일!
}  
```
```
class MethodTest01{
	public static void main(String []args){
		MyUtil mu = new MyUtil();
		mu.gugudan();
```
사용하려는 *메소드의 매개변수의 자료형*과 *전달하는 값의 자료형*이 **일치**해야함!

사용하려면 *메소드의 매개변수의 개수*와 *호출할때 전달하는 매개변수의 개수*가 **일치**해야함

하나의 파일에 두개이상의 클래스를 만들때에는 **메인메소드를 포함하는 클래스이름으로 파일명을 저장**
	
메소드의 이름이 다음과 같다면
```
int 메소드이름( ){
 int sum = 0;
 어쩌구저쩌구
 return sum;
}
```
메소드를 호출한 결과값이 int
이결과값을 메소드 호출한쪽에서 변수에 담아 다른일 처리에 사용할 수 있음
```
int  변수이름 = 메소드이름();
무슨무슨 처리...
```
#### 배열을 매개변수로 갖는 메소드
메소드자료형 메소드이름(자료형 []배열이름){
}

예를 들어 
`int []a = {1,2,3,4,5};`

라는 배열이 있고 이것을 매개변수로 받은 메소드를 만들어 보면

`void pro(int []data){ }`

이 메소드를 호출하려면 pro(a)라고 메소드 호출시에 배열이름을 전달하면 됌
이때 호출하는 배열이름과 메소드의 매개변수의 배열이름은 같아도 상관없고 달라도 상관없음
