# 복습 요약

**멀티프로세서와 멀티쓰레드를 비교하여 설명**

멀티프로세서는 하나의 컴퓨터에서 동시에 여러프로그램이 실행하는 것

멀티쓰레드는 하나의 프ㅗ그램에서 동시에 여러기능이 동작하는 것

**자바에서는 멀티쓰레드 프로그램을 위하여 Thread 클래스와 Runnable 인터페이스를 제공함**

**멀티쓰레드 프로그래밍을 위하여 Thread클래스를 상속받아 run메소드를 오버라이딩 하여 공평하게 실행할 명령어를 써주고 

쓰레드를 가동하기 위해서는 이 클래스의 객체를 생성한 다음 start 메소드를 호출함**

**쓰레드를 가동하기 위해서는 run()을 직접 호출하면 에러는 나지 않지만 공평하게 실행하는 것이 아니라 일반 메소드처럼 동작함**

**Runnable 인터페이스를 이용하여 "멀티쓰레드 프로그래밍"을 구현할 때에도 run메소드를 오버라이딩 하여 공평하게 실행시키고자 하는 명령어(들)을 써줌 
그러나 Runnable 인터페이스에는 start메소드가 없어서 쓰레드를 가동 시키기 위하여 직접 start를 호출할 수 없으며 Thread클래스로 포장하여 start를 호출해야함**

# Thread의 우선순위

1. 필요하다면 쓰레드에 우선순위를 설정할 수 있음
2. 우선순위 설정을 위하여 setPriority메소드를 이용함
3. 매개변수로 1~10까지의 정수를 전달함
4. 숫자가 높을수록 우선순위가 높음
5. 우선순위가 높다는 것은 다른 쓰레드보다는 일을 빨리 끝내달라는 의미임 
6. 우선순위의 최고값 10대신에 상수 Thread.MAX_PRIORITY, 최저값 1대신에 상수 Thread.MIN_PRIORITY, 중간값 5대신에 상수 Thread.NORM_PRIORITY를 사용할 수 있음

우선순위를 높게 설정하는 것은 가급적이면 일을 빨리 끝내달라고 요청하는 것이지 반드시 그 쓰레드가 일을 빨리 끝내는것이 보장되지는 않음

## join 메소드
쓰레드가 종료될때까지 대기 시키기 위한 메소드임

쓰레드를 가동시키면 그때부터 명령어가 순서대로 동작하지 않고 가급적이면 공평하게 실행이 되게끔 스케줄링 해줌

만약에 어떠한 명령어(들)가 쓰레드가 완전히 종료한다음 실행해야 할 때에는 

join 메소드를 호출하여 쓰레드가 모두 종료될때까지 대기하도록 함

## 임계영역

두개이상의 쓰레드가 공유하는 자원(멤버변수)에 대하여 한번에 하나의 쓰레드에게만 접근을 허용하는 영역(멤버변수)을 말함

자바에서는 임계영역의 처리를 위하여 synchronized를 사용함

한번에 하나의 쓰레드에게만 접근을 허용해야하는 메소드의 이름 왼쪽에 synchronized라고 써주면 자바가 알아서 임계영역의 처리를 해줌

즉,한번에 하나의 쓰레드만 접근하도록 lock을 걸어주고 일이 끝나면 lock을 풀어줌

TVArs 클래스 이름을 나중에 Account로 바꾸고싶음!
이클립스의 Package Explorer에서 TVArs.java에 마우스 오른쪽 단추
Refactor의 Rename을 눌러 이름을 변경함
이때에 파일명과 클래스이름 또, 그 클래스를 사용하는 다른 파일의 내용도 모두 변경됌 
그러나 컴파일된 .class파일은 생성되지 않음
여전히 TVArs.class만 있는 상태이고 바뀐 클래스의 Account.class는 없는 상태임 
그래서, 클래스이름을 바꿀때에는 그 파일을 열어 빈곳 아무데나에서 엔터를 한번 치고 "저장"해야 함
"저장"하면 자동으로 "컴파일"이 됌

## 쓰레드사이의 통신**
쓰레드를 가동시키면 가급적으로 서로 공평하게 실행되게끔 스케줄링을 해줌
늘(언제나) 공평하게 실행이 되지는 않음
어떤 특정 쓰레드가 연달아 동작하기도 함
만약 두개의 쓰레드가 반드시 1:1로 동작해야 한다면 쓰레드 사이의 통신을 통하여 구현할 수 있음!
자바의 모든 클래스들은 Object의 후손임
우리가 만드는 모든 클래스들은 묵시적으로 Object를 상속받게 됌 
Object클래스에는 쓰레드사이의 통신을 위한 wait메소드와 notify메소드가 있음
wait를 쓰레드자신을 대기상태로 두는 메소드이며 notify는 대기중인 다른쓰레드를 깨워주는 메소드임 
즉, 다른쓰레드가 일이 끝날때까지 나는 대기상태(wait)에 있도록 하고 
내가 일이 끝나면 notify()를 호출하여 대기상태에 있는 다른 쓰레드를 깨워줌으로서
쓰레드사이의 통신을 할 수 있음 
**쓰레드 사이의 통신을 위한 실습을 위하여 생산자 클래스와 소비자클래스를 만들어봄
생산자는 계속하여 새로운 제품(정수)을 생산하기만 하고 소비자는 계속하여 제품을 소비하기만 하도록 만들어봄
그런데 생산자가 새로운 제품을 만들지도 않았는데 소비가 일어나지 않도록 하고싶음
또 소비자가 아까 생산했던 제품을 소비하지도 않았는데 생산하지 않도록 하고싶음
즉, 생산자와 소비자클래스간의 wait, notify 메소드를 이용하여 생산자는 아까 만든 제품이 소비가 이루어지지 않는 동안 대기상태로 있고 소비가 일어나면 새로운 제품을 생산함
이것을 위하여 제품이라는 클래스를 먼저 만듬 
제품클래스에는 제품을 생산하는 메소드와 소비하는 메소드로 구성되며 이것들은 임계영역설정을 위하여 synchronized로 표현함 
생산자와 소비자는 제품이라는 클래스의 객체를 서로 공유하도록 만듬!

소비자는 새로운 제품을 만들기 전까지는 대기상태에 있다가 새로운 제품이 만들어지면 소비를 하도록 함

## 파일 입출력 프로그래밍
프로그램 실행결과를 화면에 출력하면 휘발성임
컴퓨터를 끄면 혹은 창을 닫으면 출력한 결과가 날아감 
만약 프로그램 실행결과를 영구적으로 기록해야 한다면 화면에 출력하는 대신
파일로 출력할 수 있음 
자바에서는 입력 및 출력을 위하여 우리가 일일이 고생할 필요없이 "스트림"을 만들어 제공함
"스트림"은 "순서있는 자료의 흐름"을 말함
"안녕하세요"라는 문자열을 출력하면 순서대로 자료가 나가야 하고 
또, 읽어들일때에도 순서대로 자료가 와야함
이와같이 순서있는 자료의 흐름을 "스트림"이라고 함 
자바에서는 스트림(입출력)을 위한 클래스들을 
java.io 패키지에 모아 놓았음 
입출력(스트림)을 위한 최상위 클래스는 크게 두가지 종류가 있음
문자단위의 입출력 : 문자단위의 입출력은 말 그대로 문자를 출력하고 읽어들이는 것 
 이렇게 생성된 파일은 메모장같은 편집기에서 바로 내용을 확인할 수 있음
이것은 확장자를 일반적으로 .txt로 만듬
바이트단위의 입출력 : 파일은 txt파일 이외의 그림파일이나 소리파일이나 동영상 처럼 특정 메모장에서 바로 내용을 확인할 수 없고 특정 프로그램에서 내용을 확인 해야 하는 파일들이 있음 이러한 파일은 바이트단위의 입출력으로 처리해야함
## 문자단위의 입출력을 위한 클래스
Reader
Writer
## 바이트단위의 입출력을 위한 클래스
InputStream
OutputStream 
