# this와 this()
## this**

클래스를 생성시 생성자의 멤버메소드의 멤버변수이름과 동일하게 될때, 생성자나 멤버메소드 안에서 멤버변수 자신을 **구별**할 목적으로 사용

## this()**

생성자가 중복정의 되어 있을 때 생성자의 **첫번째 줄**에서 다른 생성자를 동작시키고자 할 때 사용하는 키워드
**this()는 반드시 생성자의 첫번째 줄에 와야함!!!**
```
class Person{
   private String name;
   private int age;
     public Person(String name, int age){
      this.name = name;
            this.age = age; 
     }
     public Person(){
      this("홍길동",20);   //반드시 첫번째 문장에 와야함
     }
}
```

# 기본생성자

매개변수를 갖지 않는 생성자

사용자가 생성자를 한개도 만들지 않으면 자바는 **자동**으로 **기본생성자를 제공**하여 각 자료형에 따라 초기화 해줌 

**그러나 만약 사용자가 생성자를 한개라도 만들었다면 더 이상 기본 생성자를 제공하지 않음**
필요하다면 사용자가 만들어주어야 함

## 생성자 복습
1. 클래스 이름과 같은 이름의 특수한 메소드
2. 객체 생성시에 자동수행 
3. 멤버변수들의 값을 초기화 할 목적으로 사용 
4. 생성자는 일반 멤버메소드처럼 호출문에 의해서 동작하는 것이 아니라 리턴의 개념이 없음 생성자 이름 왼쪽에 void나 리턴타입을 적지 않는다 
5. 생성자의 매개변수의 개수나 자료형이 다르거나 매개변수의 순서가 다를때 중복하여 여러개 정의 가능 
6. 생성자가 중복정의 되어있을때에 생성자에 다른 생성자를 동작시키기 위하여 this()를 사용함 
7. this()를 사용할 때에는 반드시 생성자의 첫번째 문장에 와야함
8. 만약 사용자가 생성자를 한개도 만들지 않으면 기본 생성자를 제공 
9. 사용자가 생성자를 한개라도 만들기 시작하면 기본생성자를 제공하지 않음 필요하다면 사용자가 기본 생성자를 만들어야함!

# 클래스 변수와 클래스 메소드
## static 변수

클래스 설계 시 속성(멤버변수)과 동작(멤버메소드)을 분석하여 만듬

클래스의 객체를 생성하면 그 클래스를 구성하고 있는 **멤버변수들 만큼 메모리가 생성됨** 

클래스의 멤버변수들은 객체를 생성해야지만 메모리가 생성됨 **객체마다 따로 메모리가 확보됨**(*객체마다 다른 메모리가 잡힘*)

만약 모든 객체가 **공동**으로 사용할 **기억 공간이 필요**하거나 객체와 무관하게 **객체 없이도 사용할 기억공간이 필요하다면** 

클래스를 만들때에 멤버변수이름 앞에 **static**을 붙여서 변수를 만듬

클래스를 만들때에 멤버변수이름 앞에 static이 붙은 변수를 **static변수** **정적변수** **클래스변수**라고함 

이러한 클래스 변수는 **객체없이도 바로 사용**

객체없이 사용하기 위해서는 **클래스이름.변수명으로 사용** 그래서 "클래스변수"라고 함

만약 객체가 있다면 객체참조변수를 통해서도 사용할 수 있음
이때에는 객체마다 별도의 메모리를 갖는 것이 아니라 모든 객체가 동일한 메모리를 씀

## static 메소드

어떠한 클래스의 멤버메소드를 사용하기 위해서는 반드시 그 클래스의 객체를 생성하고 객체를 통해서 사용할 수 있음

만약 객체와 무관하게 **객체를 생성하지 않고도** 동작시키고자 하는 메소드가 필요하다면 **메소드이름 왼쪽에 static**을 붙임

이러한 메소드를 **"클래스메소드"(static메소드, 정적메소드)** 라고함

static메소드는 객체 없이도 사용 할 수 있으며 *만약 객체가 있다면 객체를 통해서도 사용가능* 

어떤클래스의 static이 아닌 일반 멤버변수는 반드시 객체를 생성해야만 사용할 수 있는 변수임 따라서, static메소드에서는 일반 멤버변수에 접근 할 수 없음!

***static 메소드에서는 static 멤버에만 접근할 수 있음!!!***

객체없이 사용할 수 있는 메소드이기때문에 객체를 생성해야만 하는 메모리에는 접근 할 수 없음

## static 키워드

static키워드는 클래스를 만들때에 **변수명앞**이나 **메소드명앞**에 올 수 있음 

**변수명앞**에 static을 붙이면 **클래스 변수**라고 하며 객체를 생성하지 않고 클래스 이름을 통하여 사용가능 
또, 객체가 있다면 객체를 통해서도 사용가능 , 모든 객체가 공유하는 변수임

**메소드명 앞**에 static을 붙이면 **클래스메소드**라고 하며 객체를 생성하지 않고 클래스 이름을 통하여 사용가능
또, 객체가 있다면 객체를 통해서도 사용가능, **static메소드 에서는 static멤버에만 접근가능**

**어떤클래스가 속성(멤버변수)가 없고 메소드만으로 구성이 될때에는 객체를 생성할 필요가 없음 그래서 이때에는 static 메소드로 만드는 것이 좋겠음**

## 메소드의 중복(method overloading)
생성자를 중복하여 정의 할 수 있듯이 *같은이름의 메소드를 **여러개 중복***하여 정의 (매개변수의 개수가 다르거나 자료형이 달라야함)

## 메소드 값에 의한 호출(call by Value)
메소드 호출시에 전달되는 **매개변수가 기본자료형**인 경우

메소드 호출시에 전달하는 매개변수의 값을 메소드 호출 당하는 쪽에서(메소드 안에서) 그 값을 **복사**해서 새로운 메모리가 확보됌

그래서 만약 메소드 안에서 매개변수의 내용을 바꾸더라도 호출한 쪽에서는 변경된 내용이 적용되지 않음(서로 다른 메모리이기 때문)

## 참조에 의한 호출(call by Reference)

메소드 호출시에 전달되는 **매개변수가 배열참조변수 이거나 객체 참조변수** 인 경우

메소드 호출시에 전달되는 것이 값이 아니라 **참조하고 있는 배열의 주소이거나 참조하고 있는 객체의 주소**가 메소드에게 전달됌 

따라서 메소드안에서 참조하는 객체와 메소드 호출하는 쪽에서 참조하는 객체가 서로 **동일**함

만약 메소드안에서 참조하는 객체나 배열의 내용이 변경이 될때 메소드 호출한 쪽에서도 변경된 내용이 적용



